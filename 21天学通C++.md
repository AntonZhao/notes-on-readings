---


---

<h1 id="sams-teach-yourself-c-in-one-hour-a-day">Sams Teach Yourself C++ in One Hour a Day</h1>
<blockquote>
<p><a href="https://www.amazon.com/One-Hour-Sams-Teach-Yourself/dp/0789757745/">amazon</a><br>
<a href="https://www.epubit.com/book/detail/36952">异步社区</a>, <a href="https://book.douban.com/subject/27144565/">豆瓣</a></p>
</blockquote>
<h1 id="基本知识">基本知识</h1>
<h2 id="绪论">1 绪论</h2>
<p><strong>构建</strong>可执行文件：在编译过程中，C++代码被转换为处理器能够执行的字节码。解析依存关系的工作由<strong>链接程序</strong>负责，如果链接成功，则创建一个可执行文件，供程序员执行和分发。</p>
<h2 id="c程序的组成部分">2 C++程序的组成部分</h2>
<p>C++区分大小写。</p>
<p>使用引号（""）而不是尖括号来包含自己创建的头文件。尖括号（&lt;&gt;）通常用于包含标准 头文件。</p>
<p>main( )总是返回一个整数（根据约定，程序员在程序运行成功时返回 0，并在出现错误时返回−1。程序员可利用整个整数范围，指出众多不同的成功或失败状态）。这个整数值被返回给操作系统，大多数操作系统都提供了查询功能，让您能够获悉正常终止的应用程序的返回值。</p>
<p><code>using namespace</code></p>
<p><code>std::cout（读作standard see-out）</code>：控制台输出。除显示文本外，还能显示简单算术运算的结果。<br>
<code>std::cin（读作standard see-in）</code>：从控制台读取。</p>
<p><code>&lt;&lt;</code>：流插入运算符，将数据插入输出流。<br>
<code>&gt;&gt;</code>：提取运算符，从输入流中提取数据（到指定变量）。</p>
<h2 id="使用变量和常量">3 使用变量和常量</h2>
<p>变量类型向编译器指出了变量可存储的数据的性质，编译器将为变量预留必要的空间。编译器将变量关联到内存地址以及创建 RAM 访问指令。</p>
<p>命名约定：对于变量名，采用骆驼拼写法（首字母小写），而对于诸如函数名等其他元素，采用 Pascal 拼写法（首字母大写）。</p>
<p>C++14 新增了用单引号（’’）表示的组块分隔符(chunking separator)，提高代码的可读性。<br>
如：<code>long long countryGDPChange = -70'000'000'000;</code></p>
<p>sizeof()运算符可用于确定变量的长度(单位为Byte) 或类型。<br>
C++11 引入了固定宽度的整型，以bit为单位指定整数的宽度。要使用这些类型，必须包含头文件<code>&lt;cstdint&gt;</code>。</p>
<p>C++11 引入了<strong>列表初始化</strong>来<strong>禁止缩窄</strong>：将用于初始化的变量或值放在大括号（{}）内。</p>
<p>使用auto时必须对变量进行初始化。</p>
<p>typedef定义变量别名。</p>
<p><strong>常量</strong>类似变量，只是不能修改。使用名称标识为其预留的空间的地址，但不能覆盖该空间的内容。</p>
<ul>
<li>字面常量</li>
<li>const声明的常量</li>
<li>constexpr声明的常量表达式</li>
<li>enum枚举：编译器将枚举量转换为整数，默认起始值为0，可指定。</li>
</ul>
<h2 id="管理数组和字符串">4 管理数组和字符串</h2>
<p>编译器不检查索引是否在数组范围内。</p>
<p>务必初始化数组，否则将包含未知值。</p>
<p>多维数组存储的内存是一维的。</p>
<p>动态数组：<code>std::vector</code>。</p>
<p>字符串：<code>std::string</code>。是动态的。</p>
<h2 id="使用表达式、语句和运算符">5 使用表达式、语句和运算符</h2>
<p>左值通常是内存单元，右值可以是内存单元的内容。</p>
<p>编译器将结果为0的表达式视为false，非0视为true。</p>
<p>逻辑运算符：NOT（!）、AND（&amp;&amp;）和OR（||）<br>
按位运算符：NOT（~）、AND（&amp;）、OR（|）和XOR（^）</p>
<p>sizeof()运算符确定变量占用的内存空间，单位Byte。程序员不能自定义这个运算符，因此不能重载。</p>
<p><a href="https://zh.cppreference.com/w/cpp/language/operator_precedence">运算符优先级</a></p>
<h2 id="控制程序流程">6 控制程序流程</h2>
<p><code>switch-case</code><br>
case标签须为常量。break若省略将不断与后面标签进行比较。</p>
<p>使用auto可编写一个通用的for循环：<code>for(auto ele : Elements)</code></p>
<h2 id="使用函数组织代码">7 使用函数组织代码</h2>
<p>形参（parameter）；实参（argument）。</p>
<p>带默认值的函数参数。须放在参数列表末尾。</p>
<p><strong>重载</strong>函数：名称和返回类型相同，参数不同的函数。</p>
<p><strong>内联</strong><code>inline</code>：函数被调用时就地展开。可减少执行函数调用的开销。<br>
同时也会使代码急剧膨胀，应尽可能少用inline，仅当函数非常简单时使用。</p>
<p>使用auto自动推断函数返回类型时，须先实现再调用。</p>
<h2 id="阐述指针和引用">8 阐述指针和引用</h2>
<h3 id="指针">指针</h3>
<p><strong>指针</strong>：存储内存地址的<strong>变量</strong>。即指针<br>
未初始化的指针包含的值是随机的，可能导致程序访问非法内存单元，进而导致程序崩溃。</p>
<p>引用运算符（&amp;），也叫地址运算符。<br>
解除引用运算符（*），也叫间接运算符。</p>
<h3 id="动态内存分配">动态内存分配</h3>
<p>使用new分配的自由存储区中的内存最终都需要使用对应的delete删除。</p>
<p>对指针执行递增和递减运算，编译器将认为你要指向内存块中相邻的值，而不是相邻的字节。</p>
<p>将const用于指针：</p>
<ul>
<li><code>int* const pDaysInMonth</code>：指针包含的地址是常量，不能修改，可修改指针指向的数据。</li>
<li><code>const int* pointsToInt</code>：指针指向的数据为常量，不能修改，但可修改指针包含的地址。</li>
<li><code>const int* const pHoursInDay</code>：指针包含的地址及指向的值都是常量。</li>
</ul>
<p>可将数组变量赋给类型类型与之相同的指针，如：</p>
<pre class=" language-c"><code class="prism ++ language-c"><span class="token keyword">int</span> myNumbers<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">int</span><span class="token operator">*</span> pointsToNums <span class="token operator">=</span> myNumbers<span class="token punctuation">;</span>
</code></pre>
<p>可将（*）用于数组，也可将（[]）用于指针。</p>
<h3 id="指针tips">指针tips</h3>
<p>如果有指针的多个拷贝，只需对其中一个调用delete。</p>
<p>C++提供了两种确认指针有效的方法：</p>
<ul>
<li>异常</li>
<li>new(nothrow)<pre class=" language-c"><code class="prism ++ language-c"><span class="token keyword">int</span><span class="token operator">*</span> pointsToManyNums <span class="token operator">=</span> <span class="token function">new</span><span class="token punctuation">(</span>nothrow<span class="token punctuation">)</span> <span class="token keyword">int</span> <span class="token punctuation">[</span><span class="token number">10000</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">if</span><span class="token punctuation">(</span>pointsToManyNums<span class="token punctuation">)</span> <span class="token comment">// check not NULL</span>
</code></pre>
</li>
</ul>
<h3 id="引用">引用</h3>
<p>引用是变量的<strong>别名</strong>。</p>
<p>将关键字const用于引用，禁止通过引用修改它指向的变量的值：<code>const int&amp; constRef</code></p>
<p>引用的优点之一是可避免将形参复制给实参，从而极大提高性能。</p>
<pre class=" language-c"><code class="prism ++ language-c">ReturnType <span class="token function">DoSth</span><span class="token punctuation">(</span>Type<span class="token operator">&amp;</span> parameter<span class="token punctuation">)</span><span class="token punctuation">;</span>
ReturnType Result <span class="token operator">=</span> <span class="token function">DoSth</span><span class="token punctuation">(</span>argument<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>此时parameter将是argument的别名。</p>
<h1 id="c面向对象编程基础">C++面向对象编程基础</h1>
<h2 id="类和对象">9 类和对象</h2>
<p>对于类名和成员函数名，采用Pascal风格命名。</p>
<p>句点运算符（.）<br>
指针运算符（-&gt;）</p>
<h3 id="构造函数">构造函数</h3>
<p>构造函数可在类声明中实现，也可在类声明外实现。</p>
<p>程序如不提供默认构造函数，编译器将创建一个。若提供重载了的构造函数，编译器将不会创建默认构造函数。<br>
注：参数均带默认值的构造函数也是默认构造函数。</p>
<p>包含初始化列表的构造函数，初始值可以是参数，也可以是固定的值。如：</p>
<pre class=" language-c"><code class="prism ++ language-c">class Human <span class="token punctuation">{</span>
private<span class="token punctuation">:</span>
  string name<span class="token punctuation">;</span>
  <span class="token keyword">int</span> age<span class="token punctuation">;</span>
public<span class="token punctuation">:</span>
  <span class="token function">Human</span><span class="token punctuation">(</span>string humansName<span class="token punctuation">,</span> <span class="token keyword">int</span> humansAge<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token function">name</span><span class="token punctuation">(</span>humansName<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">age</span><span class="token punctuation">(</span>humansAge<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
<h3 id="析构函数">析构函数</h3>
<p>析构函数在对象销毁时（如main()执行完毕）自动被调用。</p>
<p>析构函数不能重载，每个类都只能有一个析构函数。</p>
<h3 id="复制构造函数">复制构造函数</h3>
<p>浅复制的问题：只复制指针成员，不复制指针指向的缓冲区。<br>
若有两个对象指向同一块动态分配的内存，销毁其中一个对象时，delete[]释放这个内存块，导致另一个对象存储的指针拷贝无效。</p>
<p>复制构造函数接受一个<strong>以引用方式传入的当前类的对象</strong>作为参数。每当对象被复制时，编译器将调用复制构造函数。例：</p>
<pre class=" language-c"><code class="prism ++ language-c">class MyString <span class="token punctuation">{</span>
  <span class="token function">MyString</span><span class="token punctuation">(</span><span class="token keyword">const</span> MyString<span class="token operator">&amp;</span> copySource<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
<p>通过在复制构造函数声明中使用 const，可确保复制构造函数不会修改指向的源对象。复制构造函数的参数必须按引用传递，否则复制构造函数将不断调用自己，直到耗尽系统的内存为止。</p>
<p>赋值运算符：operator=</p>
<h3 id="构造函数和析构函数的用途">构造函数和析构函数的用途</h3>
<p>不允许复制的类：声明private复制构造函数。</p>
<p>只能有一个实例的单例类：使用私有构造函数、私有赋值运算符和静态实例成员。</p>
<pre class=" language-c"><code class="prism ++ language-c">class President <span class="token punctuation">{</span>
private<span class="token punctuation">:</span>
  <span class="token function">President</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// private default constructor</span>
  <span class="token function">President</span><span class="token punctuation">(</span><span class="token keyword">const</span> President<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// private copy constructor</span>
  <span class="token keyword">const</span> President<span class="token operator">&amp;</span> operator<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> President<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// assignment operator</span>
<span class="token punctuation">}</span>

public<span class="token punctuation">:</span>
  <span class="token keyword">static</span> President<span class="token operator">&amp;</span> <span class="token function">GetInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">static</span> President onlyInstance<span class="token punctuation">;</span> <span class="token comment">// static objects are constucted only once</span>
    <span class="token keyword">return</span> onlyInstance<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
</code></pre>
<p>禁止在栈中实例化的类：将析构函数声明为private。<br>
此时main()结束时将不能调用析构函数，可提供一个public static方法封装析构函数，并在main()中调用。</p>
<p>使用关键字explicit禁止隐式转换。</p>
<p>关键字<strong>this</strong>包含当前对象的地址，其值为&amp;object。</p>
<p>将**sizeof()**用于类及其对象时，结果相同。其值受字填充（word padding）和其他因素的影响。</p>
<p><strong>结构Struct</strong>中的成员默认为public，默认以public方式继承基结构（类成员默认为private，类默认私有继承）。</p>
<p><strong>友元</strong>：使用关键字friend。让<strong>外部类或函数</strong>能访问私有成员和方法。</p>
<pre class=" language-c"><code class="prism ++ language-c">class Human <span class="token punctuation">{</span>
private<span class="token punctuation">:</span>
  friend <span class="token keyword">void</span> <span class="token function">DisplayAge</span><span class="token punctuation">(</span><span class="token keyword">const</span> Human<span class="token operator">&amp;</span> person<span class="token punctuation">)</span><span class="token punctuation">;</span>
  string name<span class="token punctuation">;</span>
  <span class="token keyword">int</span> age<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">DisplayAge</span><span class="token punctuation">(</span><span class="token keyword">const</span> Human<span class="token operator">&amp;</span> person<span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token punctuation">}</span>
<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span>
class Human <span class="token punctuation">{</span>
private<span class="token punctuation">:</span>
  friend class Utility<span class="token punctuation">;</span>
  string name<span class="token punctuation">;</span>
  <span class="token keyword">int</span> age<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

class Utility <span class="token punctuation">{</span>
<span class="token punctuation">}</span>
</code></pre>
<p><strong>共同体Union</strong>：每次只有一个<strong>非静态数据成员</strong>处于活动状态。可将固定的内存空间解释为另一种类型。<br>
共同体成员默认public，共同体不能继承。将sizeof()用于共同体时，结果总是为共同体最大成员长度（编译器为共同体预留最大成员占用的内存量）。</p>
<p><strong>聚合初始化</strong>（aggregate initialization）条件：</p>
<ul>
<li>只包含公有和非静态数据成员；</li>
<li>不包含任何虚成员函数；</li>
<li>只涉及公有继承；</li>
<li>不包含用户定义的构造函数；</li>
</ul>
<h2 id="实现继承">10 实现继承</h2>
<p>语法：<code>class Derived: access-specifier Base {};</code></p>
<p>构造顺序：基类对象在派生类对象之前实例化；先实例化成员属性，再调用构造函数。<br>
析构顺序和构造顺序相反。</p>
<h3 id="公共继承public：">公共继承public：</h3>
<h3 id="私有继承private">私有继承private</h3>
<p>在派生类的<strong>实例</strong>中，基类的所有公有成员和方法都是私有的。即便是Base类的public成员和方法，也只能被Derived类使用（不能被Derived实例使用）</p>
<h3 id="保护继承protected">保护继承protected</h3>
<p>Derived <strong>类</strong>（注意是类不是实例）可访问Base类所有公有和保护成员。在继承层次结构外，不能通过Derived<strong>实例</strong>访问Base类公有成员。</p>
<p>仅当必要时才使用私有继承或保护继承。对于大多数私有继承情形，更好的选择是将积累对象作为派生类的一个成员属性。即“组合优于继承”。</p>
<p>切除（slicing）问题：将子类实例赋值给基类，编译器将只复制base部分，即不是整个对象。<br>
要避免切除问题，不要按值传递参数，而应以指向积累的指针或const引用的方式传递。</p>
<p>多继承</p>
<p>可用final禁止继承</p>
<h2 id="多态polymorphism">11 多态Polymorphism</h2>
<p>多态是在运行阶段实现的。</p>
<p>抽象基类：<strong>不能实例化</strong>的基类。可通过声明纯虚函数创建抽象基类：</p>
<pre class=" language-c"><code class="prism ++ language-c">class Fish <span class="token punctuation">{</span>
public<span class="token punctuation">:</span>
  virtual <span class="token keyword">void</span> <span class="token function">DoSth</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// pure virtual method</span>
<span class="token punctuation">}</span>
</code></pre>
<p>抽象基类要求派生类必须提供虚方法的实现，即指定派生类的接口。</p>
<p>关键字virtual：</p>
<ul>
<li>在函数（虚函数）声明中，virtual 意味着当基类指针指向派生对象时，通过它可调用派生类的相应函数。</li>
<li>从 Base 类派生出 Derived1 和 Derived2 类时，如果使用了关键字 virtual，则意味着再从 Derived1 和 Derived2 派生出 Derived3 时，每个 Derived3 实例只包含一个 Base 实例。避免菱形问题。</li>
</ul>
<p>可使用限定符 override 来核实被覆盖的函数在基类中是否被声明为虚的：</p>
<pre class=" language-c"><code class="prism ++ language-c">class Tuna<span class="token punctuation">:</span>public Fish <span class="token punctuation">{</span>
public<span class="token punctuation">:</span>
  <span class="token keyword">void</span> <span class="token function">Swim</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> override <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
<p>被声明为 final 的虚函数，不能在派生类中进行覆盖：</p>
<pre class=" language-c"><code class="prism ++ language-c">class Tuna<span class="token punctuation">:</span>public Fish <span class="token punctuation">{</span>
public<span class="token punctuation">:</span>
  <span class="token keyword">void</span> <span class="token function">Swim</span><span class="token punctuation">(</span><span class="token punctuation">)</span> override final <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
<p>C++不支持需复制构造函数。</p>
<p><strong>Tips</strong>:<br>
对于将被派生类覆盖的基类方法，务必将其声明为虚函数。<br>
纯虚函数导致类变成抽象基类，且在派生类中必须提供纯虚函数的实现。<br>
在派生类中声明要覆盖基类函数的函数时，务必使用关键字 override。<br>
务必使用虚继承来解决金字塔问题。<br>
别忘了给基类提供一个虚析构函数。</p>
<h2 id="运算符类型与运算符重载">12 运算符类型与运算符重载</h2>
<p>运算符除使用<strong>关键字operator</strong>外，与函数几乎没有差别。</p>
<p>可重载的单目运算符</p>
<p>可重载的双目运算符</p>
<p>不能重载的运算符（p260）</p>
<p><strong>转换运算符</strong>：使用operator关键字添加自定义运算符，实现类型转换。</p>
<p><strong>函数运算符operator()</strong> 让对象行为像函数。其用途包括决策，根据使用的操作数数量，这样的<strong>函数对象</strong>（functor）通常称为单目谓词或双目谓词。</p>
<p><strong>移动构造函数</strong>和<strong>移动赋值运算符</strong>乃性能优化功能，旨在避免复制不必要的临时值(当前语句执行完毕后就不再存在的右值)。只将资源从源移到目的地，而没有进行复制。对于那些管理动态分配资源的类，如动态数组类或字符串类，这很有用。</p>
<ul>
<li>移动构造函数<pre class=" language-c"><code class="prism ++ language-c"><span class="token function">MyString</span><span class="token punctuation">(</span>MyString<span class="token operator">&amp;&amp;</span> moveSource<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre>
</li>
<li>移动赋值运算符<pre class=" language-c"><code class="prism ++ language-c"> Sample<span class="token operator">&amp;</span> operator<span class="token operator">=</span> <span class="token punctuation">(</span>Sample<span class="token operator">&amp;&amp;</span> moveSource<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre>
</li>
</ul>
<p><strong>用户定义的字面量</strong>：operator""</p>
<pre class=" language-c"><code class="prism ++ language-c">Temperature operator<span class="token string">""</span> <span class="token function">_C</span><span class="token punctuation">(</span><span class="token keyword">long</span> <span class="token keyword">double</span> celcius<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre>
<h2 id="类型转换运算符">13 类型转换运算符</h2>
<p>类型转换是一种<strong>改变编译器对对象的解释</strong>的机制。这并不意味着改变了对象本身，而只是改变了对对象的解释。</p>
<p>类型转换运算符：语法<code>destination_type result = cast_operator&lt;destination_type&gt; (object_to_cast);</code></p>
<ul>
<li>静态类型转换 static_cast：在相关类型的指针之间进行转换。只验证指针类型是否相关，而不会执行任何运行阶段检查。</li>
<li>动态类型转换dynamic_cast：在运行阶段执行类型转换。可使用 dynamic_cast 在运行阶段判断类型，并在安全时使用转换后的指针。这种在运行阶段识别对象类型的机制称为运行阶段类型识别(runtime type identification，RTTI)。<pre class=" language-c"><code class="prism ++ language-c">Tuna<span class="token operator">*</span> objTuna <span class="token operator">=</span> dynamic_cast <span class="token operator">&lt;</span>Tuna<span class="token operator">*</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>objFish<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>objTuna<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre>
</li>
<li>reinterpret_cast：强制重新解释类型。能够将一种对象类型转换为另一种，不管它们是否相关。<br>
并没有改变源对象的二进制表示，但让编译器允许程序员访问 SomeClass 对象包含的各个字节。应尽量避免在应用程序中使用 reinterpret_cast。</li>
<li>const_cast：关闭对象的访问修饰符 const。除非万不得已，否则不要使用 const_cast 来调用非 const 函数。</li>
</ul>
<p><strong>应尽量避免使用类型转换</strong>。在现代 C++中，<strong>除 dynamic_cast 外的类型转换都是可以避免的</strong>。仅当需要满足遗留应用程序的需求时，才需要使用其他类型转换运算符。</p>
<h2 id="宏和模板简介">14 宏和模板简介</h2>
<h3 id="宏">宏</h3>
<p>预处理器在编译器之前运行，预处理器编译指令都以#打头。</p>
<p>预处理器进行死板的文本替换，而不检查替换是否正确。定义常量时，更好的选择是使用关键字 const 和数据类型。</p>
<p>使用 assert 宏验证表达式</p>
<p>宏函数将在编译前就地展开，因此简单宏的性能优于常规函数调用。这是因为函数调用要求创建调用栈、传递参数等，这些开销占用的 CPU 时间通常比函数执行的计算还多。</p>
<h3 id="模板">模板</h3>
<p>模板让程序员能够定义一种适用于不同类型对象的行为。模板是类型安全的（宏不是类型安全的）。</p>
<p>模板声明以关键字 template 打头，接下来是类型参数列表：<code>template &lt;parameter list&gt;</code></p>
<p>使用模板类时，可指定要为哪种类型具体化类。</p>
<p>包含默认参数的模板</p>
<p>在编译器看来，仅当模板类以某种方式被使用后，其代码才存在。</p>
<p>对于模板类的静态成员，通用的初始化语法:</p>
<pre class=" language-c"><code class="prism ++ language-c">template<span class="token operator">&lt;</span>template parameters<span class="token operator">&gt;</span> StaticType
ClassName<span class="token operator">&lt;</span>Template Arguments<span class="token operator">&gt;</span><span class="token punctuation">:</span><span class="token punctuation">:</span>StaticVarName<span class="token punctuation">;</span>
</code></pre>
<p>参数数量可变的模板：<code>template &lt;typename Res, typename First, typename... Rest&gt;</code></p>
<p>static_assert 让您能够在不满足指定条件时禁止编译。是一 种编译阶段断言。</p>
<h1 id="学习标准模板库stl">学习标准模板库(STL)</h1>
<h2 id="标准模板库简介">15 标准模板库简介</h2>
<h3 id="容器">容器</h3>
<ul>
<li>顺序容器</li>
<li>关联容器：按指定的顺序存储数据</li>
</ul>
<p>容器适配器(Container Adapter)是顺序容器和关联容器的变种。主要的适配器类：</p>
<ul>
<li>std::stack</li>
<li>std::queue</li>
<li>std::priority_queue</li>
</ul>
<p><img src="http://images2.imagebam.com/41/83/14/3dc1ae1046539024.png" alt=""><img src="http://images2.imagebam.com/fe/e8/fe/0beabc1046539034.png" alt=""></p>
<h3 id="迭代器">迭代器</h3>
<ul>
<li>输入迭代器</li>
<li>输出迭代器</li>
</ul>
<h3 id="算法">算法</h3>
<p>最常用的 STL 算法：</p>
<ul>
<li>std::find</li>
<li>std::find_if</li>
<li>std::reverse</li>
<li>std::remove_if</li>
<li>std::transform</li>
</ul>
<h3 id="stl字符串">STL字符串</h3>
<ul>
<li>std::string：基于 char 的 std::basic_string 具体化，用于操纵简单字符串。</li>
<li>std::wstring：基于 wchar_t 的 std::basic_string 具体化，用于操纵宽字符串，通常用于存储支持<br>
各种语言中符号的 Unicode 字符。</li>
</ul>
<h2 id="stl-string-类">16 STL string 类</h2>
<h2 id="stl-动态数组类">17 STL 动态数组类</h2>
<h2 id="stl-list-和-forward_list">18 STL list 和 forward_list</h2>
<h2 id="stl-集合类">19 STL 集合类</h2>
<h2 id="stl-映射类">20 STL 映射类</h2>
<h1 id="再谈-stl">再谈 STL</h1>
<h2 id="理解函数对象">21 理解函数对象</h2>
<p>从概念上说，函数对象是用作函数的对象；但从实现上说，函数对象是实现了 operator()的类的对象。</p>
<p>常用于 STL 算法的函数对象可分为两种：</p>
<ul>
<li>一元函数：接受一个参数的函数，如 f(x)。如果一元函数返回一个布尔值，则该函数称为<strong>谓词</strong>。</li>
<li>二元函数：接受两个参数的函数，如 f(x, y)。如果二元函数返回一个布尔值，则该函数称为<strong>二元谓词</strong>。</li>
</ul>
<p>组合两个函数对象的函数对象称为自适应函数对象。</p>
<h2 id="lambda-表达式">22 lambda 表达式</h2>
<p>lambda 表达式是一种<strong>定义匿名函数对象</strong>的简洁方式。可将 lambda 表达式视为包含公有 operator( )的匿名结构（或类）。</p>
<p>通用语法：</p>
<pre class=" language-c"><code class="prism ++ language-c"><span class="token punctuation">[</span>stateVar1<span class="token punctuation">,</span> stateVar2<span class="token punctuation">]</span><span class="token punctuation">(</span>Type1 var1<span class="token punctuation">,</span> Type2 var2<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> ReturnType <span class="token punctuation">{</span>
  Statement <span class="token number">1</span><span class="token punctuation">;</span>
  Statement <span class="token number">2</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>value or expression<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>仅当 lambda 表达式简短、高效时，才应使用它。</p>
<h2 id="stl-算法">23 STL 算法</h2>
<h2 id="自适应容器栈和队列">24 自适应容器:栈和队列</h2>
<h2 id="使用-stl-位标志">25 使用 STL 位标志</h2>
<h1 id="高级-c概念">高级 C++概念</h1>
<h2 id="理解智能指针">26 理解智能指针</h2>
<p>C++智能指针是<strong>包含重载运算符的类</strong>。能够及时、妥善地销毁动态分配的数据，并实现了明确的对象生命周期。</p>
<p>使智能指针真正“智能”的是<strong>复制构造函数、赋值运算符和析构函数</strong>的实现，它们决定了智能指针对象被传递给函数、赋值或离开作用域（即像其他类对象一样被销毁）时的行为。</p>
<p>智能指针的分类实际上就是<strong>内存资源管理策略</strong>的分类，可分为如下几类：</p>
<ul>
<li>深复制；</li>
<li>写时复制(Copy on Write，COW)；</li>
<li>引用计数；</li>
<li>引用链接；</li>
<li>破坏性复制</li>
</ul>
<p><strong>std::unique_ptr</strong>不允许复制和赋值。其复制构造函数和赋值运算符被声明为私有的，因此不能复制它，即不能将其按值传递给函数，也不能将其赋给其他指针。</p>
<p>编写使用多线程的应用程序时，可考虑使用 std::shared_ptr 和 std::weak_ptr，它们可帮助您实现线程安全和引用计数对象共享。</p>
<p><a href="https://www.boost.org/doc/libs/1_68_0/libs/smart_ptr/doc/html/smart_ptr.html">智能指针库</a></p>
<h2 id="使用流进行输入和输出">27 使用流进行输入和输出</h2>
<h3 id="重要的c流类和对象">重要的C++流类和对象</h3>
<p>控制符<br>
<img src="https://img-blog.csdn.net/20160327185621157?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p><strong>std::cout</strong></p>
<p><strong>std::cin</strong><br>
cin遇到空白后停止插入，读取整行可用getline()。</p>
<p><strong>std::fstream</strong>处理文件<br>
用open()打开文件，close()关闭文件。</p>
<pre class=" language-c"><code class="prism ++ language-c">fstream myFile<span class="token punctuation">;</span>
myFile<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"HelloFile.txt"</span><span class="token punctuation">,</span> ios_base<span class="token punctuation">:</span><span class="token punctuation">:</span>in <span class="token operator">|</span> ios_bae<span class="token punctuation">:</span><span class="token punctuation">:</span>out <span class="token operator">|</span> ios<span class="token punctuation">:</span><span class="token punctuation">:</span>trunc<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span><span class="token punctuation">(</span>myFile<span class="token punctuation">.</span><span class="token function">is_open</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// check if open() succeeded</span>
  <span class="token comment">// do sth</span>
  myFile<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>文件打开模式：</p>
<ul>
<li>ios_base::app：附加到现有文件末尾，而不是覆盖它。</li>
<li>ios_base::ate：切换到文件末尾，但可在文件的任何地方写入数据。</li>
<li>ios_base::trunc：导致现有文件被覆盖，这是<strong>默认设置</strong>。</li>
<li>ios_base::binary：创建二进制文件(默认为文本文件)。</li>
<li>ios_base::in：以只读方式打开文件。</li>
<li>ios_base::out：以只写方式打开文件。</li>
</ul>
<p><strong>std::stringstream</strong></p>
<h2 id="异常处理">28 异常处理</h2>
<p>引发异常时将对局部对象调用析构函数。<br>
如果因出现异常而被调用的析构函数也引发异常，将导致应用程序异常终止。</p>
<p>重要异常类：</p>
<ul>
<li>bad_alloc：使用 new 请求内存失败时引发。</li>
<li>bad_cast：试图使用 dynamic_cast 转换错误类型(没有继承关系的类型)时引发。</li>
<li>ios_base::failure：由 iostream 库中的函数和方法引发。</li>
</ul>
<p>可从std::exception派生自定义类，如：</p>
<pre class=" language-c"><code class="prism ++ language-c">class CustomException<span class="token punctuation">:</span> public std<span class="token punctuation">:</span><span class="token punctuation">:</span>exception <span class="token punctuation">{</span>
  string reason<span class="token punctuation">;</span>
public<span class="token punctuation">:</span>
  <span class="token function">CustomException</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> why<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token function">reason</span><span class="token punctuation">(</span>why<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

  virtual <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> <span class="token function">what</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token function">throw</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">// throw()指明可能抛出的异常类型，如throw(int)</span>
<span class="token punctuation">}</span>
</code></pre>
<p>不要在 catch( )块中包含实现逻辑或分配资源的 代码，以免在处理异常的同时导致异常。</p>
<h2 id="继续前行">29 继续前行</h2>
<h3 id="编写杰出的c代码">编写杰出的C++代码</h3>
<ul>
<li>对于 int、float 等变量，务必进行初始化。</li>
<li>务必将指针初始化为 NULL 或有效的地址— 如运算符 new 返回的地址。</li>
<li>使用数组时，绝不要跨越其边界。跨越数组边界被称为缓冲区溢出，可导致安全漏洞。</li>
<li>不要使用字符串缓冲区(char*)，也不要使用 strelen( )和 strcopy( )等函数。std::string 更安全，还提供了很多有用的方法，如获取长度、进行复制和附加的方法。</li>
<li>仅当确定要包含的元素数时才使用静态数组。如果不确定，应使用 std::vector 等动态数组。</li>
<li>声明和定义接受非 POD 类型作为输入的函数时，应考虑将参数声明为引用，以免调用函数时执行不必要的复制步骤。</li>
<li>如果类包含原始指针成员，务必考虑如何在复制或赋值时管理内存资源所有权，即应考虑编写复制构造函数和赋值运算符。</li>
<li>编写管理动态数组的实用类时，务必实现移动构造函数和移动赋值运算符，以改善性能。</li>
<li>务必正确地使用 const。理想情况下，get( )函数不应修改类成员，因此应将其声明为 const 函数。同样，除非要修改函数参数包含的值，否则应将其声明为 const 引用。</li>
<li>不要使用原始指针，而应尽可能使用合适的智能指针。</li>
<li>编写实用类时，务必花精力实现让它使用起来更容易的运算符。</li>
<li>在有选择余地的情况下，务必使用模板而不是宏。模板不但是通用的，还是类型安全的。</li>
<li>编写类时，如果其对象将存储在诸如 vector 和 list 等容器中，或者被用作映射中的Key，务必实现运算符&lt;，它将用作默认排序标准。</li>
<li>如果您编写的 lambda 表达式很长，应考虑转而使用函数对象，即实现了 operator( )的类，因为函数对象可重用，且只有一个地方需要维护。</li>
<li>绝不要认为运算符 new 肯定会成功。<strong>对于分配资源的代码，务必处理其可能引发的异常</strong>，即将其放在 try 块中，并编写相应的 catch( )块。</li>
<li>绝不要在析构函数中引发异常。</li>
</ul>

